
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "adc.h"
#include "i2c.h"
#include "tim.h"
#include "usart.h"
#include "usb_otg.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "stdio.h"
#include "string.h"
#include "mppt.h"
#include "bms.h"
#include "pdu.h"


/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */
#define DELAY 2000

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void printMPPTData(MPPT_Channel *mppt, const char *label) {
    char buffer[STR_LEN];
    snprintf(buffer, STR_LEN, "%s: %.2f V, %.2f A, %.2f W\n",
             label, mppt->voltage, mppt->current, mppt->power);
    HAL_UART_Transmit(&huart4, (uint8_t*) buffer, strlen(buffer), HAL_MAX_DELAY);
}




/* USER CODE END 0 */


int main(void)
{
	/* USER CODE BEGIN 1 */


	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/
	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	SystemClock_Config();
	MX_GPIO_Init();

	MX_ADC1_Init();
	MX_ADC2_Init();
	MX_ADC3_Init();

	MX_I2C1_Init();
	MX_I2C3_Init();

	MX_TIM2_Init();
	MX_TIM4_Init();
	MX_TIM5_Init();

	MX_UART4_Init();
	MX_USB_OTG_FS_PCD_Init();

	/* USER CODE BEGIN 2 */

	HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
	HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_4);
	HAL_TIM_PWM_Start(&htim5, TIM_CHANNEL_4);

	//MPPT VARS

	MPPT_Channel mpptX = {
		.hadc = &hadc2,
		.v_channel = ADC_CHANNEL_11,
		.i_channel = ADC_CHANNEL_10,
		.htim = &htim2,
		.tim_channel = TIM_CHANNEL_1,
		.voltage = 0,    // Inicializar como indefinido
		.current = -1,    // Inicializar como indefinido
		.power = -1,      // Inicializar como indefinido
		.prevPower = 0,
		.dutyCycle = 255 * 0.5  // 50% de 255
	};

	MPPT_Channel mpptY = {
	    .hadc = &hadc1,
	    .v_channel = ADC_CHANNEL_13,
	    .i_channel = ADC_CHANNEL_12,
	    .htim = &htim4,
	    .tim_channel = TIM_CHANNEL_4,
		.voltage = -1,    // Inicializar como indefinido
		.current = -1,    // Inicializar como indefinido
		.power = -1,      // Inicializar como indefinido
		.prevPower = 0,
		.dutyCycle = 255 * 0.5  // 50% de 255
	};

	MPPT_Channel mpptZ = {
	    .hadc = &hadc3,
	    .v_channel = ADC_CHANNEL_2,
	    .i_channel = ADC_CHANNEL_1,
	    .htim = &htim5,
	    .tim_channel = TIM_CHANNEL_4,
		.voltage = -1,    // Inicializar como indefinido
		.current = -1,    // Inicializar como indefinido
		.power = -1,      // Inicializar como indefinido
		.prevPower = 0,
		.dutyCycle = 255 * 0.5  // 50% de 255
	};

	// Definir las estructuras para cada canal de la PDU

	PDU_Channel pdu_V5 = {
	    .hadc = &hadc2,
	    .v_channel = ADC_CHANNEL_11,  // Canal ADC para voltaje de V5
	    .i_channel = ADC_CHANNEL_10,  // Canal ADC para corriente de V5
	    .voltage = 0,
	    .current = 0,
	    .label = "V5",
	    .gpio_port = GPIOB,  // Puerto GPIO de salida
	    .gpio_pin = GPIO_PIN_12  // Pin de control para 5V BIS
	};

	PDU_Channel pdu_V5bis = {
	    .hadc = &hadc2,
	    .v_channel = ADC_CHANNEL_11,  // Canal ADC para voltaje de V5bis
	    .i_channel = ADC_CHANNEL_10,  // Canal ADC para corriente de V5bis
	    .voltage = 0,
	    .current = 0,
	    .label = "V5bis",
	    .gpio_port = GPIOB,
	    .gpio_pin = GPIO_PIN_12  // Pin de control para 5V BIS
	};

	PDU_Channel pdu_V3 = {
	    .hadc = &hadc2,
	    .v_channel = ADC_CHANNEL_11,  // Canal ADC para voltaje de V3
	    .i_channel = ADC_CHANNEL_10,  // Canal ADC para corriente de V3
	    .voltage = 0,
	    .current = 0,
	    .label = "V3",
	    .gpio_port = GPIOB,
	    .gpio_pin = GPIO_PIN_11  // Pin de control para 3.3V
	};

	PDU_Channel pdu_V3bis = {
	    .hadc = &hadc2,
	    .v_channel = ADC_CHANNEL_11,  // Canal ADC para voltaje de V3bis
	    .i_channel = ADC_CHANNEL_10,  // Canal ADC para corriente de V3bis
	    .voltage = 0,
	    .current = 0,
	    .label = "V3bis",
	    .gpio_port = GPIOB,
	    .gpio_pin = GPIO_PIN_10  // Pin de control para 3.3V BIS
	};


	//Pruebas de salidas
    // Habilitar las fuentes
    enablePDU(&pdu_V3bis);
    enablePDU(&pdu_V3);
    enablePDU(&pdu_V5bis);
//    enablePDU(&pdu_V5);	//5V  		//NO ANDA Y METE RUIDO

//	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET);	//Batery out BIS

  /* USER CODE END 2 */

  /* USER CODE BEGIN WHILE */
  while (1)
  {
	  	//MPPT
        updateMPPT(&mpptX);
        updateMPPT(&mpptY);
        updateMPPT(&mpptZ);


		// Imprimir datos al puerto serie


        printMPPTData(&mpptX, "VX_in"); // Imprimir valores de MPPT para el eje X
        printMPPTData(&mpptY, "VY_in"); // Imprimir valores de MPPT para el eje Y
        printMPPTData(&mpptZ, "VZ_in"); // Imprimir valores de MPPT para el eje Z


		//PDU

        updatePDU(&pdu_V5);
        updatePDU(&pdu_V5bis);
        updatePDU(&pdu_V3);
        updatePDU(&pdu_V3bis);


		//COMUNICACION BQ76905

	  	uint8_t data;
    	HAL_I2C_Mem_Read(&hi2c1,
    	                 0x10,         		 // Dirección I2C
						 0x00,                // Registro que quieres leer
    	                 I2C_MEMADD_SIZE_8BIT,// Tamaño de la dirección (8 bits)
    	                 &data,               // Búfer donde guardar el dato leído
    	                 1,                   // Cantidad de bytes a leer
    	                 HAL_MAX_DELAY);

		HAL_I2C_Master_Transmit(&hi2c3,
								0x08 << 1,
								&data,
								1,
								HAL_MAX_DELAY);


	  //limites de voltage UV Y OV
	  //limites de corrinte (over current in discharge and OCIC)
	  //short circuit detection
	  //proteccion por temperatura alta o baja en carga y descarga

		//config bms

		// Se asume que hi2c1 está inicializado y corresponde al bus I2C
		HAL_StatusTypeDef ret;
		uint8_t tx[32];
		uint8_t rx[32];

		//----------------------------------------------------------------------------------------
		// 1) Entrar a CONFIG_UPDATE (subcomando 0x0090)
		//   Para escribir un subcomando de 16 bits (little-endian): se manda [0x3E, LSB, MSB].
		//----------------------------------------------------------------------------------------
		tx[0] = 0x3E;   // Dirección donde se escribe el subcomando
		tx[1] = 0x90;   // LSB del subcomando (0x0090)
		tx[2] = 0x00;   // MSB del subcomando
		ret = HAL_I2C_Master_Transmit(&hi2c1, 0x10, tx, 3, 100);
		if(ret != HAL_OK) { /* Manejo de error */ }

		//----------------------------------------------------------------------------------------
		// 2) Escribir VCell Mode = 2 celdas en 0x901B (Data Memory).
		//    Procedimiento:
		//      a) Mandar en 1ra Tx: [0x3E, addrLow, addrHigh, ...payload...]
		//      b) Calcular checksum y length => escribir en 0x60, 0x61
		//
		//    Ejemplo: address = 0x901B => (LSB=0x1B, MSB=0x90), data=0x04
		//----------------------------------------------------------------------------------------
		// a) Mandamos dirección + data
		tx[0] = 0x3E;       // se escribe en 0x3E
		tx[1] = 0x1B;       // LSB de 0x901B
		tx[2] = 0x90;       // MSB de 0x901B
		tx[3] = 0x02;       // Valor = 2 (2 celdas)
		ret = HAL_I2C_Master_Transmit(&hi2c1, 0x10, tx, 4, 100);
		if(ret != HAL_OK) { /* error */ }



		// b) Calcular checksum = ~ ( sum( [addrLow, addrHigh, data...] ) ) & 0xFF
		//    length = dataLen + 4 => (1 byte data) + 2 address + 2 (chksum+length) => total 1+2+2=5 => dataLen+4
		{
		  uint8_t sumTemp = 0x1B + 0x90 + 0x02; // la sumatoria
		  uint8_t chksum  = (uint8_t)(~sumTemp);
		  uint8_t lengthVal = 1 + 4;           // (dataLen=1) +4 = 5

		  tx[0] = 0x60;       // dónde se escribe el checksum
		  tx[1] = chksum;
		  tx[2] = lengthVal;  // 5
		  ret = HAL_I2C_Master_Transmit(&hi2c1, 0x10, tx, 3, 100);
		  if(ret != HAL_OK) { /* error */ }
		}

		//----------------------------------------------------------------------------------------
		// 3) Escribir Enabled Protections A = 0xE1 en 0x9024
		//----------------------------------------------------------------------------------------
		// a) Dirección + data => [0x3E, 0x24, 0x90, 0xE1]
		tx[0] = 0x3E;
		tx[1] = 0x24;  // LSB de 0x9024
		tx[2] = 0x90;  // MSB
		tx[3] = 0xE1;  // Valor
		ret = HAL_I2C_Master_Transmit(&hi2c1, 0x10, tx, 4, 100);
		if(ret != HAL_OK) { /* error */ }

		// b) checksum + length => sum(0x24 + 0x90 + 0xE1)= 0x24+0x90=0xB4(180) +0xE1=0x195(405 decimal=0x195)
		//    sum &0xFF= 0x95, chksum=~0x95=0x6A
		{
		  uint8_t sumTemp = (uint8_t)(0x24 + 0x90 + 0xE1); // 0x24 +0x90= 0xB4, +0xE1= 0x195 => LSB=0x95
		  uint8_t chksum  = (uint8_t)(~sumTemp); // ~0x95=0x6A
		  uint8_t lengthVal = 1 + 4; // dataLen=1 => +4=5

		  tx[0] = 0x60;
		  tx[1] = chksum;      // 0x6A
		  tx[2] = lengthVal;   // 5
		  ret = HAL_I2C_Master_Transmit(&hi2c1, 0x10, tx, 3, 100);
		  if(ret != HAL_OK) { /* error */ }
		}


		//----------------------------------------------------------------------------------------
		// 4) Escribir Cell Undevoltage TH = 0x0BB8 en 0x902E
		//----------------------------------------------------------------------------------------
		// a) Dirección + data => [0x3E, 0x2E, 0x90, 0xB8, 0x0]
		tx[0] = 0x3E;
		tx[1] = 0x2E;  // LSB de 0x9024
		tx[2] = 0x90;  // MSB
		tx[3] = 0xB8;  // Valor
		tx[4] = 0x0B;
		ret = HAL_I2C_Master_Transmit(&hi2c1, 0x10, tx, 4, 100);
		if(ret != HAL_OK) { /* error */ }

		// b) checksum + length => sum(0x24 + 0x90 + 0xE1)= 0x24+0x90=0xB4(180) +0xE1=0x195(405 decimal=0x195)
		//    sum &0xFF= 0x95, chksum=~0x95=0x6A
		{
		  uint8_t sumTemp = (uint8_t)(0x24 + 0x90 + 0xE1); // 0x24 +0x90= 0xB4, +0xE1= 0x195 => LSB=0x95
		  uint8_t chksum  = (uint8_t)(~sumTemp); // ~0x95=0x6A
		  uint8_t lengthVal = 1 + 4; // dataLen=1 => +4=5

		  tx[0] = 0x60;
		  tx[1] = chksum;      // 0x6A
		  tx[2] = lengthVal;   // 5
		  ret = HAL_I2C_Master_Transmit(&hi2c1, 0x10, tx, 3, 100);
		  if(ret != HAL_OK) { /* error */ }
		}


		//----------------------------------------------------------------------------------------
		// 4) Salir de CONFIG_UPDATE (subcomando 0x0092)
		//----------------------------------------------------------------------------------------
		tx[0] = 0x3E;  // subcmd
		tx[1] = 0x92;  // LSB
		tx[2] = 0x00;  // MSB
		ret = HAL_I2C_Master_Transmit(&hi2c1, 0x10, tx, 3, 100);
		if(ret != HAL_OK) { /* error */ }

		//----------------------------------------------------------------------------------------
		// 5) Habilitar FET_EN con subcomando 0x0022
		//----------------------------------------------------------------------------------------

		/*
		tx[0] = 0x3E;
		tx[1] = 0x22;  // LSB
		tx[2] = 0x00;  // MSB
		ret = HAL_I2C_Master_Transmit(&hi2c1, 0x10, tx, 3, 100);
		HAL_Delay(2);

		*/

		//----------------------------------------------------------------------------------------
		// (Opcional) 6) Forzar manualmente DSG_ON: Comando directo 0x68 => 1 byte con bit0=1
		//----------------------------------------------------------------------------------------

		tx[0] = 0x68;   // FET Control
		tx[1] = 0x01;   // 0b00000001 => DSG_ON=1
		ret = HAL_I2C_Master_Transmit(&hi2c1, 0x10, tx, 2, 100);
		if(ret != HAL_OK) { }

		//----------------------------------------------------------------------------------------
		// 7) Leer bit DSG en Battery Status (0x12). BatteryStatus() = 2 bytes, LSB en rx[0]
		//    => bit0 de rx[0] indica DSG (1=encendido, 0=apagado)
		//----------------------------------------------------------------------------------------
		tx[0] = 0x12; // Comando directo a leer
		ret = HAL_I2C_Master_Transmit(&hi2c1, 0x10, tx, 1, 100);
		if(ret != HAL_OK) { /* error */ }

		// Recibir 2 bytes
		memset(rx, 0, sizeof(rx));
		ret = HAL_I2C_Master_Receive(&hi2c1, 0x10, rx, 2, 100);
		if(ret != HAL_OK) { /* error */ }



		//----------------------------------------------------------------------------------------
		// Habilitar Alarm Enable escribiendo en 0x66 con el valor 0x0060 (FULLSCAN y ADSCAN)
		//----------------------------------------------------------------------------------------

		tx[0] = 0x66;  // Dirección de Alarm Enable
		tx[1] = 0x60;  // LSB del valor 0x0060 (FULLSCAN, ADSCAN)
		tx[2] = 0x00;  // MSB del valor 0x0060
		ret = HAL_I2C_Master_Transmit(&hi2c1, 0x10, tx, 3, 100);
		if(ret != HAL_OK) { /* error */ }


		uint8_t regValue;
		HAL_StatusTypeDef status;
		uint8_t msg = 0xFF;

		regValue = 0x01;

		status = HAL_I2C_Mem_Read(&hi2c1, 0x10, 0x68, I2C_MEMADD_SIZE_8BIT, &regValue, 1, HAL_MAX_DELAY);


		if (status != HAL_OK)
		{
			HAL_I2C_Master_Transmit(&hi2c3,
									0x08 << 1,
									&msg,
									1,
									HAL_MAX_DELAY);
		}else{
			HAL_I2C_Master_Transmit(&hi2c3,
									0x08 << 1,
									&regValue,
									1,
									HAL_MAX_DELAY);
		}


		status = HAL_I2C_Mem_Write(&hi2c1, 0x10, 0x68, I2C_MEMADD_SIZE_8BIT, &regValue, 1, HAL_MAX_DELAY);




		//CALENTAMIENTO Y CONTROL DE TEMPERATURA
        if (1) {
        //if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_8) == GPIO_PIN_SET) {
            HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_SET);  // Activar calefactor
//    		HAL_Delay(500);
//            HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);  // desctivar calefactor

            char MSG_CALENT_OK[60] = "\n Calefactor encendido. Alarma activa. \n";
            HAL_UART_Transmit(&huart4, (uint8_t*) MSG_CALENT_OK,50, HAL_MAX_DELAY);

        } else {
        	char MSG_CALENT_ERROR[60] =  "\n Calefactor apagado. Todas las alarmas inactivas.\n";
            HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);  // Apagar calefactor
            HAL_UART_Transmit(&huart4, (uint8_t*) MSG_CALENT_ERROR,50, HAL_MAX_DELAY);
        }

		//MODO BAJO CONSUMO

		//ALMACENAMIENTO EN FLASH DE VARIBLES

	  	if(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_2) == GPIO_PIN_SET){
	  		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET);	//Batery out BIS
	  	}

		HAL_Delay(DELAY);


        HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);  // Activar calefactor
		HAL_Delay(DELAY);



    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 96;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV6;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
