/*
 * bms.c
 *
 *  Created on: Mar 2, 2025
 *      Author: apple
 */

#include "bms.h"
#include "i2c.h"


// Definir el comando de FET Control (0x29)
#define FET_CONTROL_CMD 0x29
#define BQ76905_I2C_ADDR 0x10  // Dirección I2C del BQ76905, asegúrate de que sea la correcta




HAL_StatusTypeDef BQ76905_WriteRegister(uint8_t reg, uint8_t* data, uint16_t len) {
	HAL_StatusTypeDef status;
    status = HAL_I2C_Master_Transmit(&hi2c3, BQ76905_I2C_ADDR, &reg, 1, HAL_MAX_DELAY);
    if (status != HAL_OK) {
        return status; // Retorna el error si no se pudo enviar el registro
    }

    // Leer los datos del registro
    return HAL_I2C_Master_Receive(&hi2c3, BQ76905_I2C_ADDR, data, len, HAL_MAX_DELAY);
}




// Función para leer un registro específico del BQ76905
HAL_StatusTypeDef BQ76905_ReadRegister(uint8_t reg, uint8_t* data, uint16_t len) {
    HAL_StatusTypeDef status;

    // Enviar el registro desde el cual leeremos
    status = HAL_I2C_Master_Transmit(&hi2c3, BQ76905_I2C_ADDR, &reg, 1, HAL_MAX_DELAY);
    if (status != HAL_OK) {
        return status; // Retorna el error si no se pudo enviar el registro
    }

    // Leer los datos del registro
    return HAL_I2C_Master_Receive(&hi2c3, BQ76905_I2C_ADDR, data, len, HAL_MAX_DELAY);
}

// Función para leer un registro del BQ76905
HAL_StatusTypeDef BQ76905_ReadRegister_test(uint8_t regAddr, uint8_t *data, uint16_t size) {
    return HAL_I2C_Mem_Read(&hi2c3, BQ76905_I2C_ADDR, regAddr, I2C_MEMADD_SIZE_8BIT, data, size, HAL_MAX_DELAY);
}

// Función para leer el voltaje de una celda
void ReadCellVoltage(I2C_HandleTypeDef *hi2c, uint8_t cell) {
    uint8_t cmd_addr = 0x14 + (cell * 2);
    uint8_t result;
	char buffer[100];

	HAL_UART_Transmit(&huart4, (uint8_t) BQ76905_ReadRegister_test(cmd_addr, result, 2),100, HAL_MAX_DELAY);


    if (BQ76905_ReadRegister_test(cmd_addr, result, 2) == HAL_OK) {
    	sprintf(buffer, "Cellda %d = %d mV\n", cell, result); // @suppress("Float formatting support")
    	HAL_UART_Transmit(&huart4, (uint8_t*) buffer, strlen(buffer), HAL_MAX_DELAY);
    } else {
    	char MSG_READ_ERROR[60] =  "\n Error al leer \n";
        HAL_UART_Transmit(&huart4, (uint8_t*) MSG_READ_ERROR,50, HAL_MAX_DELAY);
    	HAL_UART_Transmit(&huart4,(uint8_t*) result,100, HAL_MAX_DELAY);
    	//HAL_UART_Transmit(&huart4, result[1],100, HAL_MAX_DELAY);

    }
}

// Función para forzar el FET de descarga a encenderse
  void enable_Discharge_FET() {
      uint8_t command[2];
      command[0] = FET_CONTROL_CMD;  // Comando FET Control
      command[1] = 0x01;  // Valor para forzar el FET de descarga (DSG) a encenderse (CHG no se fuerza)

      // Enviar el comando a través de I2C
      HAL_I2C_Master_Transmit(&hi2c1, BQ76905_I2C_ADDR, command, 2, HAL_MAX_DELAY);
  }

  // Función para deshabilitar el FET de descarga (opcional)
  void disable_Discharge_FET() {
      uint8_t command[2];
      command[0] = FET_CONTROL_CMD;  // Comando FET Control
      command[1] = 0x00;  // Valor para deshabilitar el FET de descarga

      // Enviar el comando a través de I2C
      HAL_I2C_Master_Transmit(&hi2c1, BQ76905_I2C_ADDR, command, 2, HAL_MAX_DELAY);
  }




//BMS

typedef struct {
    uint16_t cell1_voltage;        // Voltaje de la celda 1 (mV)
    uint16_t cell2_voltage;        // Voltaje de la celda 2 (mV)
    uint8_t alert_status_A;        // Registro de alertas A
    uint8_t fault_status_A;        // Registro de fallas A
    uint8_t alert_status_B;        // Registro de alertas B
    uint8_t fault_status_B;        // Registro de fallas B
    uint16_t battery_status;       // Registro de estado de la batería
} BatteryData;












