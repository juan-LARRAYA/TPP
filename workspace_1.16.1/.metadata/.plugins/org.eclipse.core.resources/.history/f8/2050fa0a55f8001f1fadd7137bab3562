/*
 * bms.c
 *
 *  Created on: Mar 2, 2025
 *      Author: apple
 */

#include "bms.h"
#include "i2c.h"
#include "usart.h"
#include <stdio.h>
#include <string.h>

// Función para enviar un subcomando al BQ76905 (no requiere checksum)
HAL_StatusTypeDef BQ76905_WriteSubcommand(BQ76905_Device *bms, BQ76905_Registers subcmd) {
    uint8_t tx[TX_SUBCOMMAND_LEN] = {BASE_ADDRESS, (uint8_t)(subcmd & 0xFF), (uint8_t)(subcmd >> 8)};
    return HAL_I2C_Master_Transmit(bms->hi2c, BQ76905_I2C_ADDR, tx, TX_SUBCOMMAND_LEN, HAL_MAX_DELAY);
}


// Función para escribir en un registro (requiere checksum si es de memoria)
HAL_StatusTypeDef BQ76905_WriteRegister(BQ76905_Device *bms, BQ76905_Registers reg, uint8_t *data, uint8_t len) {
    uint8_t tx[32];
    tx[0] = BASE_SUBCOMMAND_ADDRESS; // Dirección base
    tx[1] = (uint8_t)(reg & 0xFF);  // LSB del registro
    tx[2] = (uint8_t)(reg >> 8);    // MSB del registro

    // Copiar datos al buffer de transmisión
    memcpy(&tx[3], data, len);

    // Enviar datos al registro
    HAL_StatusTypeDef ret = HAL_I2C_Master_Transmit(bms->hi2c, BQ76905_I2C_ADDR, tx, len + 3, HAL_MAX_DELAY);
    if (ret != HAL_OK) return ret;

    // Si el registro pertenece a la memoria, escribir checksum
    return BQ76905_WriteChecksum(bms, reg, data, len);
}

// Función para calcular y escribir el checksum
HAL_StatusTypeDef BQ76905_WriteChecksum(BQ76905_Device *bms, BQ76905_Registers reg, uint8_t *data, uint8_t len) {
    uint8_t sum = (uint8_t)(reg & 0xFF) + (uint8_t)(reg >> 8);

    for (uint8_t i = 0; i < len; i++) {
        sum += data[i];
    }

    uint8_t chksum = ~sum;      // Invertimos el complemento a uno
    uint8_t lengthVal = len + 4;  // Longitud = datos + dirección + (checksum + longitud)

    uint8_t tx[3] = {0x60, chksum, lengthVal};  // Dirección del checksum
    return HAL_I2C_Master_Transmit(bms->hi2c, BQ76905_I2C_ADDR, tx, 3, HAL_MAX_DELAY);
}


// Función para leer un registro
HAL_StatusTypeDef BQ76905_ReadRegister(BQ76905_Device *bms, BQ76905_Registers reg, uint8_t *rxData, uint8_t len) {
    HAL_StatusTypeDef ret = HAL_I2C_Master_Transmit(bms->hi2c, BQ76905_I2C_ADDR, (uint8_t*)&reg, 1, HAL_MAX_DELAY);
    if (ret != HAL_OK) return ret;
    return HAL_I2C_Master_Receive(bms->hi2c, BQ76905_I2C_ADDR, rxData, len, HAL_MAX_DELAY);
}


// Función para configurar el BQ76905
void BQ76905_Configure(BQ76905_Device *bms) {
    uint8_t data[2];

    // Entrar en modo CONFIG_UPDATE
    BQ76905_WriteSubcommand(bms, CONFIG_UPDATE);

    // Configurar VCell Mode (2 celdas)
    data[0] = 0x02;
    BQ76905_WriteRegister(bms, VCELL_MODE, data, 1);

    // Habilita protecciones OCC, OCD, SCD y COV
    data[0] = 0xE1;
    BQ76905_WriteRegister(bms, ENABLED_PROT_A, data, 1);

    // Umbral de bajo voltaje (en mV) 0x0B *256 + 0x8b = 3000 mV
    data[0] = 0xB8;
    data[1] = 0x0B;
    BQ76905_WriteRegister(bms, CELL_UV_THRESHOLD, data, 2);

    // Salir de modo CONFIG_UPDATE
    BQ76905_WriteSubcommand(bms, CONFIG_EXIT);
}

// Función para leer datos desde el BQ76905
void BQ76905_ReadData(BQ76905_Device *bms) {
    uint8_t rx[6];

    // Leer voltaje de las celdas
    BQ76905_ReadRegister(bms, VCELL_MODE, rx, 4);
    bms->cell1_voltage = rx[0] | (rx[1] << 8);
    bms->cell2_voltage = rx[2] | (rx[3] << 8);

    // Leer estado de la batería
    BQ76905_ReadRegister(bms, BATTERY_STATUS, (uint8_t*)&bms->battery_status, 2);

    // Leer alertas y fallas
    BQ76905_ReadRegister(bms, ALARM_ENABLE, &bms->alert_status_A, 1);
    BQ76905_ReadRegister(bms, ENABLED_PROT_A, &bms->fault_status_A, 1);
    BQ76905_ReadRegister(bms, FET_CONTROL, &bms->alert_status_B, 1);
}


